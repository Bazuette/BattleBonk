package libayon.module.modules.exploit;

import libayon.BattleBonk;
import libayon.event.events.client.UpdateEvent;
import libayon.event.events.packets.PacketReceivedEvent;
import libayon.event.events.packets.PacketSentEvent;
import libayon.event.events.player.PreMotionEvent;
import libayon.module.Category;
import libayon.module.Mode;
import libayon.module.Module;
import libayon.utils.network.PacketUtils;
import libayon.utils.timers.Timer;
import net.minecraft.network.NetHandlerPlayServer;
import net.minecraft.network.Packet;
import net.minecraft.network.play.client.C00PacketKeepAlive;
import net.minecraft.network.play.client.C03PacketPlayer;
import net.minecraft.network.play.client.C0CPacketInput;
import net.minecraft.network.play.client.C13PacketPlayerAbilities;

import java.util.LinkedList;

public class Disabler extends Module {
    private final BattleBonk bb = BattleBonk.instance;
    public Timer timer = new Timer();
    public LinkedList<Packet<NetHandlerPlayServer>> packets = new LinkedList<>();
    private double y = 0;

    public Disabler() {
        super("Disabler", "Disables some anticheat", 0, Category.EXPLOIT, Mode.BATTLEASYA, Mode.VULCAN, Mode.VERUS);
    }

    @Override
    public void onPreMotion(PreMotionEvent e) {

    }

    @Override
    public void onDisable() {
        mc.timer.timerSpeed = 1;
    }

    @Override
    public void onEnable() {
        timer.reset();
    }

    @Override
    public void setup() {
        moduleSettings.addDefault("Delay", 1.0);
    }

    @Override
    public void onUpdate(UpdateEvent e) {
        boolean movementModuleToggled = false;
        for (Module m : BattleBonk.instance.getModuleManager().getModules(Category.MOVEMENT)) {
            if (m.isToggled())
                movementModuleToggled = true;
        }
        switch (getMode()) {
            case BATTLEASYA:
                if (timer.hasReached(40)) {
                    C13PacketPlayerAbilities c13 = new C13PacketPlayerAbilities();
                    c13.setCreativeMode(true);
                    c13.setInvulnerable(true);
                    PacketUtils.sendPacketNoEvent(c13);
                }
                timer.reset();
                break;
            case VULCAN:
                if (mc.thePlayer.ticksExisted % 2 == 0) {
                    PacketUtils.sendPacketNoEvent(new C0CPacketInput(Integer.MAX_VALUE, Integer.MAX_VALUE, false, false));
                }
                break;
            case VERUS:
                if (mc.thePlayer.ticksExisted % 11 == 0) {
                    PacketUtils.sendPacketNoEvent(new C03PacketPlayer.C04PacketPlayerPosition(mc.thePlayer.posX, mc.thePlayer.posY - 78.4F, mc.thePlayer.posZ, true));
                    mc.timer.timerSpeed = 0.5f;
                } else {
                    mc.timer.timerSpeed = 1.0f;
                }
                break;
        }

    }

    @Override
    public void onPacketSent(PacketSentEvent e) {
        Packet p = e.getPacket();
        if (mc.thePlayer == null)
            return;
        switch (getMode()) {
            case VULCAN:
                if (mc.thePlayer.ticksExisted % 3 == 0) {
                }
                break;
            case BATTLEASYA:
                if ((p instanceof C00PacketKeepAlive || p instanceof C03PacketPlayer) && mc.thePlayer.ticksExisted % 3 == 0) {
                    e.setCancelled(true);
                }
                break;
            case VERUS:
                break;
        }
    }

    @Override
    public void onPacketReceived(PacketReceivedEvent e) {
        Packet p = e.getPacket();
        boolean movementModuleToggled = false;
        for (Module m : BattleBonk.instance.getModuleManager().getModules(Category.MOVEMENT)) {
            if (m.isToggled())
                movementModuleToggled = true;
        }
    }
}
